/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2008-2016 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_ELEVATION_POOL_H
#define OSGEARTH_ELEVATION_POOL_H

#include <osgEarth/Common>
#include <osgEarth/ElevationLayer>
#include <osgEarth/GeoData>
#include <osgEarth/TileKey>
#include <osgEarth/ThreadingUtils>
#include <osgEarth/Containers>
#include <osg/Timer>
#include <osg/Texture2D>
#include <map>
#include <unordered_map>

namespace osgEarth
{
    using namespace Threading;

    class OSGEARTH_EXPORT ElevationSample2
    {
    public:
        ElevationSample2(const Distance& e, const Distance& r) : _e(e), _r(r) { }
        const Distance& elevation() const { return _e; }
        const Distance& resolution() const { return _r; }
        bool valid() const { return _r > 0.0f; }
    private:
        Distance _e, _r;
    };

    // CONTAINER for elevation data on the system "somewhere".
    // could be HF, could be image, could be texture .....
    // for now, let's say it's a heightfield.
    // abstract that away with the API.
    // GL_R16F value
    // Encoded normal/scope?
    // Look up functions?
    class ElevationTexture : public osg::Texture2D
    {
    public:
        ElevationTexture(const GeoHeightField& hf, const NormalMap* normalMap);

        virtual ~ElevationTexture();

        //! Gets the elevation at the map coordinates. These coordinates must
        //! be in the SRS used to create the texture.
        ElevationSample2 getElevation(double x, double y) const;

        //! Gets the elevation using normalized [0..1] coordinates.
        ElevationSample2 getElevationUV(double u, double v) const;

        //! Extent of the texture
        const GeoExtent& getExtent() const { return _extent; }

        //! Normal map associated with the elevation data, if available.
        osg::Texture2D* getNormalMapTexture() const { return _normalTex.get(); }

    private:
        GeoExtent _extent;
        Distance _resolution;
        ImageUtils::PixelReader _read;
        osg::ref_ptr<osg::Texture2D> _normalTex;
    };

    class ElevationUser
    {
    public:
        virtual ElevationTexture* getElevationData() =0;
    };

    namespace Internal
    {
        struct EPKey
        {
            TileKey _tilekey;
            unsigned _revision;

            inline bool operator < (const EPKey& rhs) const {
                if ( _tilekey < rhs._tilekey ) return true;
                if ( rhs._tilekey < _tilekey ) return false;
                return _revision < rhs._revision;
            }
            inline bool operator == (const EPKey& rhs) const {
                return _tilekey == rhs._tilekey &&
                    _revision == rhs._revision;
            }
        };
    }
}

#ifdef OSGEARTH_CXX11
namespace std {
    // std::hash specialization for Key
    template<> struct hash<osgEarth::Internal::EPKey> {
        inline size_t operator()(const osgEarth::Internal::EPKey& value) const {
            return value._tilekey.hash();
        }
    };
}
#endif

namespace osgEarth
{
    /**
     * Stores pointers to elevation data wherever it might exist
     * so we can quickly access it for queries.
     */
    class OSGEARTH_EXPORT ElevationPool2 : public osg::Referenced
    {
    public:
        typedef osg::observer_ptr<ElevationTexture> WeakPointer;
        typedef osg::ref_ptr<ElevationTexture> Pointer;
        typedef Lockable<std::unordered_map<Internal::EPKey, WeakPointer> > WeakLUT;

        //! Localized cache a client can use when making multiple queries 
        //! in a similar geographic area.
        class OSGEARTH_EXPORT WorkingSet
        {
        public:
            WorkingSet(unsigned size =64);
            typedef LRUCache<Internal::EPKey,Pointer> LRU;
            LRU _lru;
        };

    public:
        ElevationPool2();

        void setMap(const Map* map);

        ElevationSample2 getSample(
            const GeoPoint& p, 
            WorkingSet* ws);

        ElevationSample2 getSample(
            const GeoPoint& p, 
            const Distance& resolution,
            WorkingSet* ws);

        bool getTile(
            const TileKey& key,
            bool getNormalMap,
            osg::ref_ptr<ElevationTexture>& out_elev,
            WorkingSet* ws);

        virtual ~ElevationPool2();

    private:

        osg::observer_ptr<const Map> _map;

        // stores weak pointers to elevation textures wherever they may exist in the system
        WeakLUT _globalLUT;

        void* _index;
        
        int _mapRevision;

        void refresh(const Map*);

        unsigned _tileSize;

        WorkingSet* _L2;

        ElevationSample2 getSample(const GeoPoint& p, unsigned maxLOD, const Map* map, WorkingSet* ws);

        unsigned getLOD(double x, double y) const;

        osg::ref_ptr<ElevationTexture> getOrCreateRaster(
            const Internal::EPKey& key, 
            const Map* map, 
            bool includeNormalMap, 
            WorkingSet* ws);

        bool findExistingRaster(
            const Internal::EPKey& key,
            WorkingSet* ws,
            osg::ref_ptr<ElevationTexture>& result,
            bool* fromWorkingSet,
            bool* fromL2Cache,
            bool* fromGlobalWeakLUT);
    };

}




namespace osgEarth
{

    // defined at the end of this file
    class ElevationEnvelope;
    class Map;

    //! Result of an elevation query.
    struct ElevationSample : public osg::Referenced
    {
        float elevation;
        float resolution;
        ElevationSample(float a, float b) : elevation(a), resolution(b) { }
    };

    /**
     * A pool of elevation data that can be used to manage regional elevation
     * data queries. To use this, call createEnvelope() and use that object
     * to make your elevation queries at a particular LOD. The queries can
     * be anywhere geographically, but the algorithm will optimize lots of
     * queries in a particular area (like a terrain tile).
     *
     * Each Map contains an ElevationPool you can access for queries against
     * that Map.
     *
     * // usage. Note: Envelope instances are not thread-safe!
     * ElevationEnvelope* envelope = pool->createEnvelope(srs, lod);
     * float z = envelope->getElevation(point);
     */
    class OSGEARTH_EXPORT ElevationPool : public osg::Referenced
    {
    public:
        /** ctor */
        ElevationPool();

        /** Sets the map from which to read elevation data. */
        void setMap(const Map* map);

        /**
         * Sets a vector of ElevationLayers from which to read elevation data.
         * Omit this is you just want to use all the elevation layes in the Map
         * that you set with setMap().
         */
        void setElevationLayers(const ElevationLayerVector& layers);
        const ElevationLayerVector& getElevationLayers() const { return _layers; }

        /** Sets the dimension of heightfield tiles to read from the map */
        void setTileSize(unsigned size);
        unsigned getTileSize() const { return _tileSize; }

        /** Creates a query envelope to use for elevation queries in a certain area.
            Note: the ElevationEnvelope API is not thread-safe */
        ElevationEnvelope* createEnvelope(const SpatialReference* srs, unsigned lod);

        //! Queries the elevation at a GeoPoint for a given LOD.
        Future<ElevationSample> getElevation(const GeoPoint& p, unsigned lod=23);

        /** Maximum number of elevation tiles to cache */
        void setMaxEntries(unsigned maxEntries) { _maxEntries = maxEntries; }
        unsigned getMaxEntries() const          { return _maxEntries; }

        /** Clears any cached tiles from the elevation pool. */
        void clear();
        
        void stopThreading();

    protected:

        osg::observer_ptr<const Map> _map;

        ElevationLayerVector _layers;

        enum Status
        {
            STATUS_EMPTY = 0u,
            STATUS_IN_PROGRESS = 1u,
            STATUS_AVAILABLE = 2u,
            STATUS_FAIL = 3u
        };

        // Single elevation tile along with its load status
        class Tile : public osg::Referenced
        {
        public:
            Tile() : _status(STATUS_EMPTY), _loadTime(0) { }
            TileKey             _key;        // key used to request this tile
            GeoHeightField      _hf;
            OpenThreads::Atomic _status;
            osg::Timer_t        _loadTime;
        };

        // Custom comparator for Tile that sorts Tiles in a set from
        // highest resolution to lowest resolution; This ensures we are
        // sampling overlapping tiles in the proper order
        struct TileSortHiResToLoRes
        {
            bool operator()(
                const osg::ref_ptr<Tile>& lhs,
                const osg::ref_ptr<Tile>& rhs) const
            {
                // works because the KEY less-than function checks the LOD number
                // first, which corresponds to the resolution. Higher LOD = higher res.
                return rhs->_key < lhs->_key;
            }
        };
                
        // Keeps track of the most-recently-used tiles, in order from MRU (front)
        // to LRU (back). Multiple pointers to the same Tile may exist in the MRU list.
        // Once all pointers to a Tile disappear from the MRU (by popping off the back)
        // the corresponding Tile observer in the Tiles data structure will go NULL
        // and the Tile will destruct.
        typedef std::list<osg::ref_ptr<Tile> > MRU;
        MRU _mru;

        // Cached set of tiles, sorted by TileKey. These are observer pointers; the 
        // actual references are held in the MRU. That way when all pointers drop off
        // the back of the MRU, the Tile is destroyed and the main observer goes to 
        // NULL and is removed.
        typedef UnorderedMap<TileKey, osg::observer_ptr<Tile> > Tiles;
        Threading::Lockable<Tiles> _tiles;
        //Threading::Mutex  _tilesMutex;

        // Track the number of entries in the MRU manually since std::list::size
        // can be O(n) on some platforms
        unsigned _entries;
        unsigned _maxEntries;

        // dimension of sampling heightfield
        unsigned _tileSize;

        // QuerySet is a collection of Tiles, sorted from high to low resolution,
        // that a ElevationEnvelope uses for a terrain sampling opteration.
        typedef std::set<osg::ref_ptr<Tile>, TileSortHiResToLoRes> QuerySet;

        // Memory of tilekeys that returned other tilekeys from fetchTileFromMap
        typedef UnorderedMap<TileKey,TileKey> KeyFetchMemory;

        // Asynchronous elevation query operation
        struct GetElevationOp : public osg::Operation {
            GetElevationOp(ElevationPool*, const GeoPoint&, unsigned lod);
            osg::observer_ptr<ElevationPool> _pool;
            GeoPoint _point;
            unsigned _lod;
            Promise<ElevationSample> _promise;
            void operator()(osg::Object*);
        };
        friend struct GetElevationOp;
        osg::ref_ptr<osg::OperationQueue> _opQueue;
        std::vector< osg::ref_ptr<osg::OperationThread> > _opThreads;

        virtual ~ElevationPool();

    protected:

        // safely popluate the tile; called when Tile._status = IN_PROGRESS
        bool fetchTileFromMap(const TileKey& key, const ElevationLayerVector& layers, KeyFetchMemory& memory, Tile* tile) const;
        
        // safely fetch a tile from the central repo, loading from map if necessary
        bool getTile(const TileKey& key, const ElevationLayerVector& layers, KeyFetchMemory& memory, osg::ref_ptr<Tile>& output);
        
        // safely fetch a tile from the central repo, loading from map if necessary
        bool tryTile(const TileKey& key, const ElevationLayerVector& layers, KeyFetchMemory& memory, osg::ref_ptr<Tile>& output);

        // safely remove the oldest item on the MRU
        void popMRU();

        // clears and resets the pool.
        void clearImpl();

        friend class ElevationEnvelope;
    };


    /**
     * Set of terrain tiles corresponding to a geographic extent that the pager
     * uses to clamp a feature set. You cannot create this object directly;
     * instead call ElevationPool::createEnvelope().
     *
     * ElevationEnvelope is NOT thread-safe. Use a separate instance from each thread.
     * The preferred usage pattern is to create an Envelope, use it for multiple
     * queries, and then discard.
     */
    class OSGEARTH_EXPORT ElevationEnvelope : public osg::Referenced
    {
    public:
        //! Context object that the caller can use to maintain
        //! information about a particular object
        class Context
        {
        private:
            typedef std::list< osg::ref_ptr<ElevationPool::Tile> > TileMRU;
            TileMRU _tiles;
            friend class ElevationEnvelope;
        };

        /**
         * Gets a single elevation, or returns NO_DATA_VALUE upon failure.
         */
        float getElevation(double x, double y);

        //! Gets a single elevation or returns NO_DATA_VALUE upon failure.
        //! Passing in an "owner" will help the Envelope remember the last
        //! time you queried an elevation for a particular object, and 
        //! can speed up
        float getElevation(double x, double y, Context& context);

        /**
         * Gets a single elevation along with the resolution of the data from
         * which that sample was taken.
         */
        std::pair<float, float> getElevationAndResolution(double x, double y);

        /**
         * Gets a elevation value for each input point and puts them in output.
         * Returns the number of successful queries. Failed queries are set to
         * NO_DATA_VALUE in the output vector.
         */
        unsigned getElevations(
            const std::vector<osg::Vec3d>& input,
            std::vector<float>& output);

        /**
         * Gets the elevation extrema over a collection of point data.
         * Returns false if the points don't fall inside the envelope
         */
        bool getElevationExtrema(
            const std::vector<osg::Vec3d>& points, 
            float& out_min, float& out_max);

        /**
         * The SRS that this envelope expects query points to be in
         */
        const SpatialReference* getSRS() const;

        /**
         * LOD at which this envelope will try to sample the elevation
         */
        unsigned getLOD() const { return _requestedLOD; }

    protected:
        ElevationEnvelope();
        virtual ~ElevationEnvelope();
        void collectDataExtents();

        ElevationLayerVector _layers;
        ElevationPool::QuerySet _tiles;
        osg::ref_ptr<const SpatialReference> _inputSRS;
        unsigned _lod, _requestedLOD;
        osg::observer_ptr<ElevationPool> _pool;
        osg::ref_ptr<const Profile> _mapProfile;
        friend class ElevationPool;
        ElevationPool::KeyFetchMemory _memory;
        typedef std::vector<int> RevisionVector;
        RevisionVector _revisions;
        typedef std::list<DataExtent> SortedDataExtentList;
        SortedDataExtentList _dataExtentsSortedHiToLoRes;
        unsigned _queries, _contexthits, _cachehits, _newcontexts, _fails;

    private:
        bool sample(double x, double y, Context* context, float& out_elevation, float& out_resolution);
    };

} // namespace

#endif // OSGEARTH_ELEVATION_POOL_H
